%SSDD internal clustering validity index
% according to the paper, we reproduce the algorithm.
%author:wang yizhang
clc;clear;close all
addpath('D:\mega\work\evaluation', 'D:\mega\work\Complicate','D:\mega\work\UCI','D:\mega\work\drawGraph');
addpath('D:\mega\work\Celldata');
load('compound.mat');
%% compute identified local density-->definition 1inner-clusters distance
distset = computeSimi(data);
for i=1:size(distset,1)
    distset(i,i)=inf;
end
[sdismat,index] = sort(distset,2);%sdismat-->knn matrix with ascending order
% k nearest neighbour
cluster=label';%for each cluster generated by clustering-->cluster
%要算一个类里面的近邻，还没有算
N=2;% the numner of neighbors
back=[];
for i=unique(cluster)
    %     l=0.03*length(find(cluster==i));%l-->3%of each cluster's data points number
    %     l=round(l);
    l=N;
    temp=find(cluster==i);
    for j=find(cluster==i)
        knnindx=index(j,1:l);% 保存近邻的序号，用于判断这些近邻是否属于当前类。
        for k=1:length(knnindx)
            if ismember(knnindx(k),temp)==0
                knnindx(k)=0;
                %                 fprintf('不属于当前类');
            end
        end
        ld(j)=l/(sum(sdismat(j,[find(knnindx>0)])));%local density of all data points -->ld according to definition 1
        %类内距离
    end
end
num=0;
figure();
% col=[0.002,0.01,0.05];%color
for i=unique(cluster)
    clusterindex=unique(cluster);
    temp_back=[];
    %     l=0.03*length(find(cluster==i));%l-->3%of each cluster's data points number
    l=N;
    temp=find(cluster==i);
    for j=find(cluster==i)
        knnindx=index(j,1:l);% 保存近邻的序号，用于判断这些近邻是否属于当前类。
        for k=1:length(knnindx)
            if ismember(knnindx(k),temp)==0
                knnindx(k)=0;
                %                 fprintf('不属于当前类');
            end
        end
        if ld(j)>=max(ld(index(j,find(knnindx>0))))    %ld（x）>ld(xl)
            %             fprintf('it is a backbone point \n');
            num=num+1;
            back(j)=1;%如果是back points，就赋值为1
            temp_back(j)=1;
            % j
        end
    end
    %% 得到了每个类中的back points-->temp_back%%%%%%%%对于类内的所有
    %backbone points生成最小生成树。
    mstdata=data(find(temp_back==1),:);
    distset1 = computeSimi(mstdata);
    G=graph(distset1);
    %     numedges(G)
    % p = plot(G,'EdgeLabel',G.Edges.Weight);
    %     figure();
    % p = plot(G);
    [T,pred] = minspantree(G);
    %     highlight(p,T)
    %     numedges(T)
    gedge=T.Edges.EndNodes;% 生成树中的顶点对
    weigh=T.Edges.Weight;%生成树中的路径长度
    drawgraph(label,data);
    x=data(:,1);
    y=data(:,2);
    scatter(x(back==1),y(back==1),5,'k','filled');
    hold on;
    %% 求每个类的BAVDens值-->每个类的密度DC value.
    inside=[];
    for m=1:size(gedge,1)
        count_points=0;%%求以中间值为圆心的圆内点数
%         line(mstdata(gedge(m,1:2),1),mstdata(gedge(m,1:2),2),'Color',i*col);
           line(mstdata(gedge(m,1:2),1),mstdata(gedge(m,1:2),2))
        hold on;
        %         inside(gedge(m,1),gedge(m,2))=
        %1 求出两个顶点的中间值。
        center=[mean(mstdata(gedge(m,:),1)),mean(mstdata(gedge(m,:),2))];
        %求以中间值为圆心的圆内点数
        for n=1:length(temp)
            X=data(temp(n),:);
            if sqrt(sum((X - center).^2))<=0.5*weigh(m)% less than radius, inside the hyper-sphere
                count_points=count_points+1;
            end
        end
        inside(gedge(m,1),gedge(m,2))=count_points/(weigh(m)^2);%以顶点间距离作为直径，中心点作为圆心的圆内的点的个数。-->BAVDens
    end
    find(clusterindex==i)
    DC(find(clusterindex==i))=(max(inside(inside>0))-min(inside(inside>0)))/max(inside(inside>0))%the density change of a cluster ci(DC(i)) along its backbone.
    
    hold on;
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %     fprintf('*******');
end

%% inter-clusters distances
% 每个类的backbone points 列表 back==1
back_index=find(back==1);%backbone points的序列号row number
back_idx=cluster(back_index);%backbone points聚类结果，生成的类标签。
near_back_index=[];%存储离backbone points最近的类内点的序列号。
% 互相最近的backbone points pairs
BNPdens=[];
for i=1:length(unique(back_idx))
    for j=1:length(unique(back_idx))
        if i==j
            BNPdens(i,j)=0;
            continue;
        end
        %两个类之间的原始距离矩阵
        first_cluster_index=back_index(find(back_idx==i));%第i类所有backbone points
        last_cluster_index=back_index(find(back_idx==j));%第j类所有backbone points
        simi_between_cluster=distset(first_cluster_index,last_cluster_index);%任意两个类数据点组成的距离矩阵。
        [M,I]=min(simi_between_cluster,[],2);%I 是类i中每个点的对应最近的backbone points。
        I;   %两个类的所有点集合
        clusteri=find(cluster==i);
        clusterj=find(cluster==j);
        
        inter_cluster=[clusteri clusterj];
        inter_cluster_data=data(inter_cluster,:);
        %
        %% 计算第i个类的icd值
        bb_first_weigh=[];
        for  k=1:length(first_cluster_index)
            first_cluster_index(k);%某个bb点的序列号
            index(first_cluster_index(k),1:N);% bb点的n个近邻。
            bbdata=data([first_cluster_index(k)  index(first_cluster_index(k),1:N)],:);
            distset2 = computeSimi(bbdata);
            G2=graph(distset2);
            [T2,pred2] = minspantree(G2);
            gedge2=T2.Edges.EndNodes;% 生成树中的顶点对
            weigh2=T2.Edges.Weight;%生成树中的路径长度
            bb_first_weigh(k)=mean(weigh2);%某个bb点的MST平均边权重
        end
        ICDi(i)=mean(bb_first_weigh);
        %% 计算第j个类的icd值，并且计算Rij值
        bb_2_weigh=[];
        for  k2=1:length(last_cluster_index)
            bbdata=data([last_cluster_index(k2)  index(last_cluster_index(k2),1:N)],:);
            distset3 = computeSimi(bbdata);
            G3=graph(distset3);
            [T3,pred3] = minspantree(G3);
            gedge3=T3.Edges.EndNodes;% 生成树中的顶点对
            weigh3=T3.Edges.Weight;%生成树中的路径长度
            bb_2_weigh(k)=mean(weigh3);%某个bb点的MST平均边权重
        end
        ICDj(j)=mean(bb_2_weigh);
        Rij=max(ICDi(i),ICDj(j));
        %         Rij=10
        %% 计算BNPDens值
        for z=1:length(I)
            [M2,I2]=min(simi_between_cluster(:,I(z)));
            if I2==z
                fisrt_bb_index=first_cluster_index(z);%类i点的标号。
                last_bb_index=last_cluster_index(I(z));%类j点的标号。
                %fisrt_bb_index 和last_bb_index 是互为近邻的。
                fprintf('%d和%d互为近邻backbone points pair\n', fisrt_bb_index,last_bb_index);
                %找到离backbone points pairs最近的类内点
                pa=data(index(fisrt_bb_index,1),:);%pa
                pb=data (index(last_bb_index,1),:);%pb
                center2=pa+pb;
                center2=center2./2;%两个近邻点的中心点。
                %如果有数据点（i类和j类中的）离center2的距离小于半径，则并入圈内，计算inside（pa,pb）
                count_points2=0;
                for kk=1:size(inter_cluster_data,1)
                    xx=inter_cluster_data(kk,:);
                    if sqrt(sum((xx - center2).^2))<=Rij% less than radius, inside the hyper-sphere
                        count_points2=count_points2+1;
                    end
                end
                inside2(z)=count_points2/((2*Rij)^2);
                %高密度区域。
                %计算半径Rij
            end
        end
        BNPdens(i,j)=mean(inside2);
        %找到backpoints （bb）和他的N近邻形成的最小生成树，从而计算每个类的ICD值
        %         back_index(j)
        %         sdismat(back_index(j),)
    end
end
BNPdensreal=[];
for i=1:size(BNPdens,1)
    BNPdensreal(i)=mean(BNPdens(i,:))/max(mean(BNPdens(i,:))+mean(DC));
end
% mean(BNPdensreal)
% mean(DC
alpha=0.25;

SSDD=sum(alpha.*DC+(1-alpha)*BNPdensreal)
